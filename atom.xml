<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Stay foolish, stay hungry.]]></title>
  <link href="http://jeffreylyg.github.io/atom.xml" rel="self"/>
  <link href="http://jeffreylyg.github.io/"/>
  <updated>2014-05-19T02:44:33+08:00</updated>
  <id>http://jeffreylyg.github.io/</id>
  <author>
    <name><![CDATA[Jeffrey Lee]]></name>
    <email><![CDATA[jeffreylyg@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Performance Tips]]></title>
    <link href="http://jeffreylyg.github.io/blog/2014/05/16/performance-tips/"/>
    <updated>2014-05-16T11:28:00+08:00</updated>
    <id>http://jeffreylyg.github.io/blog/2014/05/16/performance-tips</id>
    <content type="html"><![CDATA[<blockquote><p>注：此为毕业设计中学院要求的翻译与自己所做毕设相关且不少于2万字符英文原始资料的任务，由于自己毕设做的是Android方面的开发，所以决定翻译一下Android官方文档中Training和API Guides中的部分内容。由于水平有限，如有错误，望理解。</p></blockquote>

<h2><a href="http://developer.android.com/training/articles/perf-tips.html">原文链接</a></h2>

<br/>


<p>这份文档主要涉及当结合使用一些微优化时可以提高应用程序的整体性能，但让这些优化给你的应用程序带来显著的性能影响是不可能的。选择正确的算法与数据结构应该总是你首先要考虑的，但这些内容在本份文档的范围之外。你可以用这份文档中所写的这些提示作为通用的编程技巧，而且为了通用的代码效率你也可以融入到你的编程习惯当中。</p>

<p>编写高效代码有两条基本规则：</p>

<ul>
<li><p>不要做你不需要做的工作。</p></li>
<li><p>如果能避免分配内存就不要分配内存。</p></li>
</ul>


<p>当微优化一个Android应用程序时面临最棘手的问题之一就是你的应用程序肯定要运行在多种类型的硬件上。不同版本的虚拟机运行在不同的处理器上的运行速度也是不同的。甚至不是一般的情况例如简单的说“X设备比Y设备快（慢）F倍”以及从一个设备上得到的结果扩展到其它设备上。特别是在模拟器上的测试几乎不会告诉你什么关于在任何设备上的性能。在带与不带JIT的设备之间也有巨大的差异：对带JIT设备来说是最好的代码但在不带JIT的设备上不总是最好的。</p>

<p>为确保你的应用在各种各样的设备上表现良好，请确保你的各级代码是高效的并致力优化应用的性能。</p>

<h3>避免创建不必要的对象</h3>

<p>创建对象从来不是不需要代价的。即使带有线程临时对象分配池的分代垃圾回收器可以使分配时的代价低廉一点，但分配内存怎么都比不分配内存的代价昂贵。</p>

<p>如果你在你的应用里分配更多的对象，你就会强制定期的垃圾收集，创造一种“打嗝”的用户体验。在Android 2.3版本引入的并发垃圾收集器有所补救，但应始终避免不必要的工作。</p>

<p>因此，你应该避免创建你不需要的对象实例。一些可以起到帮助的东西的例子：</p>

<ul>
<li><p>如果你有一个方法返回一个字符串，你知道它的结果无论如何总是被追加在一个<a href="http://developer.android.com/reference/java/lang/StringBuffer.html"><code>StringBuffer</code></a>后面，改变你的签名和实现使该函数可以直接追加，而不是创建一个短期的临时对象。</p></li>
<li><p>当从一组输入数据提取字符串，尝试返回原始数据的一个子串而不是创建它的一个副本时，你会创建一个新的String对象，但它会和这个数据共享<code>char[]</code>。(做一个权衡就是如果你只使用原始输入的一小部分，在这种方式下你得在内存处处保留着这份原始数据。)</p></li>
</ul>


<p>一个有些更激进的想法是切片多维数组转换成并行的单个一维数组：</p>

<ul>
<li><p><code>int</code>数组比<code>Integer</code>对象的数组更好，但这也推广得到一个事实，即整数的两个平行阵列也比<code>(int, int)</code>的对象数组的效率高很多。这同样适用于基本类型的任意组合。</p></li>
<li><p>如果你需要实现一个存储着<code>(Foo, Bar)</code>元组对象的容器，要记住，两个平行的<code>Foo[]</code>和<code>Bar[]</code>数组通常要比自定义的<code>(Foo, Bar)</code>对象的单个数组更好。（当然，唯一的例外是当你设计一个让其它代码来访问的API时，在速度方面做一个小的妥协通常更好来达到良好的API设计的目的。）</p></li>
</ul>


<p>一般来说，尽可能地避免创建短期的临时对象。越少的对象创建意味着越少次数的垃圾收集，这对用户体验有直接的影响。</p>

<h3>多使用静态的方法和属性</h3>

<p>如果你不需要访问一个对象的字段，请确保你的方法是静态的。这样将会使调用大约有15%~20%的速度提升。这也是一个很好的习惯，因为你可以从方法签名告诉调用者调用该方法不能改变对象的状态。</p>

<h3>将常量声明为Static和Final类型</h3>

<p>思考下面的在类顶部的声明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="kt">int</span> <span class="n">intVal</span> <span class="o">=</span> <span class="mi">42</span><span class="o">;</span>
</span><span class='line'><span class="kd">static</span> <span class="n">String</span> <span class="n">strVal</span> <span class="o">=</span> <span class="s">&quot;Hello, world!&quot;</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当一个类第一次被使用时编译器生成一个叫做<code>&lt;clinit&gt;</code>的类初始化方法会被执行。该方法存储值42到变量<code>intVal</code>里，并为变量<code>strVal</code>从类文件字符串常量表里提取一个引用。当这些值被引用后，它们能用字段查找来访问。</p>

<blockquote><p>注： 此优化只适用于原始类型和<code>String</code>常量，不是任意的引用类型。不过，尽可能地声明常量为<code>static final</code>是很好的做法。</p></blockquote>

<h3>避免内部的<code>Getters/Setters</code></h3>

<p>在本地语言例如C++很常见使用getters(<code>i = getCount()</code>)而不是直接访问字段<code>(i = mCount)</code>。这在C++里是一个很好的习惯并且也经常在其它面向对象语言例如C#和Java中实践，因为编译器通常是内联访问，如果你需要限制或调试字段访问你可以在任何时候添加代码。</p>

<p>然而，这在Android上不是一个很好的办法。虚方法的调用通常是非常耗时的，远远超过了实例字段查找。遵循共同的面向对象的编程习惯并有getter和setter的公有接口是合理的，但在一个类中你应该直接访问字段。</p>

<p>如果没有JIT，直接字段访问大约是调用一个微不足道的getter的3倍快。有了JIT之后(直接字段访问像访问本地一样快捷)直接字段访问大约是调用一个微不足道的getter的7倍快。</p>

<blockquote><p>请注意，如果你使用了<strong>ProGuard</strong>，你可以两全其美因为<strong>ProGuard</strong>为你提供了内联访问。</p></blockquote>

<h3>使用增强的For循环语法</h3>

<p>增强的<code>for</code>循环(有时也被称为&#8221;for-each&#8221;循环)，可用于实现了<code>Iterable</code>接口的集合和数组。如果使用集合，一个迭代器会被分配出来让接口调用<code>hasNext()</code>和<code>next()</code>方法。如果使用<code>ArrayList</code>，一个手写的计数循环大约是它的3倍快(不管有没有使用JIT)，但是对其他集合来说，增强的for循环语法完全等同于明确的迭代器的用法。</p>

<p>遍历一个数组通常有以下几种选择：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mSplat</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Foo</span><span class="o">[]</span> <span class="n">mArray</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">zero</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sum</span> <span class="o">+=</span> <span class="n">mArray</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">mSplat</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">one</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Foo</span><span class="o">[]</span> <span class="n">localArray</span> <span class="o">=</span> <span class="n">mArray</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">localArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sum</span> <span class="o">+=</span> <span class="n">localArray</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">mSplat</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">two</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Foo</span> <span class="n">a</span> <span class="o">:</span> <span class="n">mArray</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span><span class="o">.</span><span class="na">mSplat</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>zero()</code>方法是最慢的。因为JIT还不能优化掉每一次迭代循环时得到数组长度的代价。</p>

<p><code>one()</code>方法是较快的。它把所有东西都放进了本地变量中从而避免了查找。仅仅数组长度提供了性能优势。</p>

<p><code>two()</code>方法在没有JIT的设备上是最快的，在拥有JIT的设备上和<code>one()</code>方法没什么区别。它采用了Java编程语言1.5版本中引入的增强的for循环语法。</p>

<p>因此，你应该采用增强的for循环作为默认用法，但对性能关键的<code>ArrayList</code>迭代来说考虑用手写的技术循环。</p>

<blockquote><p>提示：参见Josh Bloch&rsquo;s Effective Java中的第46条.</p></blockquote>

<h3>考虑用私有内部类包访问而不是私有访问</h3>

<p>思考下面的类定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Inner</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">void</span> <span class="nf">stuff</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Foo</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">doStuff</span><span class="o">(</span><span class="n">Foo</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">mValue</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">mValue</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Inner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Inner</span><span class="o">();</span>
</span><span class='line'>        <span class="n">mValue</span> <span class="o">=</span> <span class="mi">27</span><span class="o">;</span>
</span><span class='line'>        <span class="n">in</span><span class="o">.</span><span class="na">stuff</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">doStuff</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Value is &quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的关键是我们定义了一个私有内部类(<code>Foo$Inner</code>)直接访问外部类的私有方法和私有实例字段。这是合法的，并且如预期代码打印出了“Value is 27”。</p>

<p>问题是虚拟机认为从<code>Foo$Inner</code>访问Foo的私有成员是非法的因为<code>Foo</code>和<code>Foo$Inner</code>是不同的类，即使Java语言允许内部类访问外部类的私有成员。要弥补差距，编译器生成了一对合成方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/*package*/</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">Foo</span><span class="o">.</span><span class="na">access</span><span class="n">$100</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">foo</span><span class="o">.</span><span class="na">mValue</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="cm">/*package*/</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">Foo</span><span class="o">.</span><span class="na">access</span><span class="n">$200</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">foo</span><span class="o">.</span><span class="na">doStuff</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>内部类会调用这些静态方法在它任何需要访问外部类<code>mValue</code>字段或者调用外部类<code>doStuff()</code>方法的时候。这句话的意思是上面的代码真正归结到你通过访问方法访问成员字段的情况。前面我们谈到了访问器是如何比直接字段访问慢的，所以这是一个特定的语言习语造成的“隐形”性能损失的例子。</p>

<p>如果你在性能热点上使用这样的代码，你可以通过声明内部类访问的字段和方法为包访问而不是私有访问来避免开销。不幸的是这意味着字段可以直接被其它类在同一个包中被访问，所以你不应该在公共API中使用这种方式。</p>

<h3>避免使用浮点数</h3>

<p>作为一个经验法则，在Android设备上浮点数比整数慢2倍。</p>

<p>在速度方面，<code>float</code>和<code>double</code>在更现代的硬件上没有区别。空间方面，double是float的两倍大。在台式机上，假设空间不是问题，你应该更倾向于用<code>double</code>而不是<code>float</code>。</p>

<p>此外，即使是整数，一些处理器具有硬件乘法但缺少硬件除法。在这种情况下，如果你是正在设计哈希表或做大量数学运算的人整数除法和取模操作在软件中的运行是你应该考虑的东西。</p>

<h3>了解和使用库</h3>

<p>除了所有常用的更喜欢用库代码而不是你自己的代码的理由外，记住，系统是可以自由更换调用库函数与手写代码的汇编，这可能比JIT为相应的Java生成的最好的代码要更好。这里典型的例子是<code>String.indexOf()</code>和相关的API，Dalvik用内联征替换了。类似的， 在带有JIT的Nexus One上<code>System.arraycopy()</code>方法大约是手写代码的循环的9倍快。</p>

<blockquote><p>提示：参见Josh Bloch&rsquo;s Effective Java第47条。</p></blockquote>

<h3>谨慎使用本地方法</h3>

<p>使用Android NDK的本地方法开发你的应用时不一定比用Java语言更有效率。一方面，有与Java到本地的过渡相关的成本，以及JIT不能跨界优化。如果你正在分配本地资源(本地堆上的内存，文件描述符或其它任何东西)，很明显地它在安排及时收集这些资源上更困难。你还需要为每个架构编译运行之上的代码（而不是依赖于拥有JIT）。你甚至可能为了考虑相同的架构要编译多个版本：为G1的ARM处理器编译的本地代码在Nexus One上的ARM处理器上不能充分利用，为Nexus One的ARM处理器编译的代码不能在G1的ARM处理器上运行。</p>

<p>本地代码主要有用的方面是当你有一个想要移植到Android的存在的本地代码库，而不是为了加速你用Java语言写的Android应用的某些部分。</p>

<p>如果你确实需要使用本地代码，你应该阅读我们的<a href="http://developer.android.com/training/articles/perf-jni.html">JNI提示</a>。</p>

<blockquote><p>参加Josh Bloch&rsquo;s Effective Java第54条。</p></blockquote>

<h3>性能神话</h3>

<p>在没有JIT的设备上，通过一个确切类型的变量调用方法比接口调用方法更高效这是事实(因此，例如通过<code>HashMap map</code>比<code>Map map</code>调用方法更快捷，即使两种情况中的map类型都是<code>HashMap</code>)。但这种情况不是2倍慢的情况，真实的差别更像是6%。此外，JIT使这两种调用没有什么区别了。</p>

<p>在没有JIT的设备上，缓存字段访问比重复访问字段快20%。有了JIT，字段访问的成本约等于本地访问，所以这不是一个值得优化的地方除非你觉得它使你的代码更易于阅读。(final, static 和 static final字段也是如此。)</p>

<h3>保持测量</h3>

<p>在开始优化之前，确保你有需要解决的问题。确保你能精确地测量你现有的性能，否则你将无法衡量你所尝试的选择的收益。</p>

<p>本文档提出的每项主张都有一个基准支持。这些基准的资源都可以在<a href="code.google.com%20%22dalvik%22%20project">code.google.com &ldquo;dalvik&rdquo; project</a>中找到。</p>

<p>这些基准是用Caliper microbenchmarking Java框架建立的。很难得到正确的微基准，所以Caliper用自己的方式为你做这项很艰难的事情，甚至检测出一些你没有测量你认为你在测量的东西。(因为，比如说虚拟机已经成功地优化了所有的代码了。)我们强烈建议你有Caliper来运行你自己的微基准。</p>

<p>你可能发现<code>TraceView</code>对分析很有用，但要认识到它目前是禁用JIT的，可能导致由JIT优化代码来的时间被弄错这一点很重要。尤其重要的是在通过TraceView数据的建议作出改变之后要确保产生的代码在没有TraceView时运行确实运行的更快。</p>

<p>如需更多分析和调试应用程序的帮助，请参阅下列文档:</p>

<ul>
<li><a href="http://developer.android.com/tools/debugging/debugging-tracing.html">Profiling with Traceview and dmtracedump</a></li>
<li><a href="http://developer.android.com/tools/debugging/systrace.html">Analysing Display and Performance with Systrace</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Genymotion, the fastest Android emulator for app testing and presentation]]></title>
    <link href="http://jeffreylyg.github.io/blog/2014/04/22/genymotion/"/>
    <updated>2014-04-22T23:33:44+08:00</updated>
    <id>http://jeffreylyg.github.io/blog/2014/04/22/genymotion</id>
    <content type="html"><![CDATA[<p>各位做Android开发的Developers可能早已受够了Google自带的模拟器，它确实又慢又卡，所以大多数Developers都是用真机调试，然而真机自然也有它的不方便之处，那就是你需要一台测试真机，这个一般公司都能给你提供，最主要的是它还是比较慢，做过iOS的人都喜欢用模拟器比真机多一点，除非一些在模拟器上调试不了的功能，因为iOS的模拟器比真机还快，还不需要安装一系列必要的Profile，之前做iOS的时候无不感叹iOS模拟器的方便，想着Android什么时候也能有这样一款模拟器就好了。今天偶然发现了这款叫<a href="http://www.genymotion.com/"><strong>Genymotion</strong></a>的模拟器，支持跨平台，亲测后只能用一句话来形容：“它真的太棒了”！启动速度和运行速度和自带的完全不在一个数量级上，是自带的几十倍，堪比iOS模拟器。强烈推荐做Android开发的同学们以后都用这款模拟器。也许发现的有点晚，但总比一直没有发现好吧，简单Google了一下发现网上配置教程也比较多，其实也不需要什么教程，按照官网上的做就行了，还是比较容易上手的，下面简单的来说一下安装过程和安装好后遇到的一些问题吧。</p>

<!--more-->


<p><img src="http://jeffreylyg.github.io/images/2014-4-22/1.png"></p>

<h2>安装过程</h2>

<ol>
<li><p>首先安装VirtualBox，所以它能在Windows，Mac和Linux上都可以运行，这也是它比本地模拟器更快的原因。</p></li>
<li><p>从官网下载后安装然后注册一个账号即可，点击运行如下图所示：<img src="http://jeffreylyg.github.io/images/2014-4-22/2.png"> 怎么样，界面是不是很漂亮？</p></li>
<li><p>用之前注册好的账号登录后选择一款手机型号或者自定义也行，例如我选择了我最喜欢的Nexus 5，然后就从服务器上去下载相应的虚拟机了，如下图所示：<img src="http://jeffreylyg.github.io/images/2014-4-22/3.png"></p></li>
</ol>


<br />


<p>IntelliJ、Android Studio和Eclipse（不过Eclipse应该大多数人都不用了吧，和IDEA系列比简直太弱了啊）都有相应的插件，在官网上都可以下到。IDEA系列安装插件如下图所示，在Setting的Plugins里点击Install  plugin from disk找到所在位置安装就行。<img src="http://jeffreylyg.github.io/images/2014-4-22/4.png"></p>

<h2>遇到的问题</h2>

<p>这是网上很多配置教程没有的，也是我自己亲自遇到的问题。编译项目后在<strong>Genymotion</strong>模拟器上运行时发现报<code>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</code>的错误，这是因为<strong>Genymotion</strong>只支持x86结构，不支持ARM，如果你的项目是必须运行在ARM上的话，那就必须安装<a href="http://s5.filetrip.net/dl.php?fn=L3AvMjgzMjIvMTk1MDQyLUdlbnltb3Rpb24tQVJNLVRyYW5zbGF0aW9uX3YxLjEuemlw&amp;dn=R2VueW1vdGlvbi1BUk0tVHJhbnNsYXRpb25fdjEuMS56aXA=&amp;fs=OTM5MDI1MA==">Genymotion-ARM-Translation_v1.1.zip</a>，点击链接下载后在<strong>Genymotion</strong>模拟器的HomeScreen上把这个zip包拖拽上去就安装好了。</p>

<p>怎么样，看完了整个过程是不是觉得很简单？那还等什么呢，赶紧安装吧，体验<strong>Genymotion</strong>带来的快速和便捷吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clang Error: -Wunused-command-line-argument-hard-error-in-future]]></title>
    <link href="http://jeffreylyg.github.io/blog/2014/03/24/clang-error-wunused-command-line-argument-hard-error-in-future/"/>
    <updated>2014-03-24T02:29:32+08:00</updated>
    <id>http://jeffreylyg.github.io/blog/2014/03/24/clang-error-wunused-command-line-argument-hard-error-in-future</id>
    <content type="html"><![CDATA[<p>在公司的电脑上用<strong>Octopress</strong>搭好个人Blog后进行了一些初步设置后因为工作太忙然后搁那儿就没动了，等周末时间空出来后准备用自己的Mac Air重新搭建和配置一下Octopress以便以后都用自己的电脑在闲暇的时间来写写博客。在搭建时执行 <code>bundle install</code> 命令时总是报如下的错误：</p>

<!--more-->


<pre><code>Gem::Installer::ExtensionBuildError: ERROR: Failed to   build gem native extension.

/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rb --with-cflags=-w
checking for main() in -lc... yes
creating Makefile

make "DESTDIR="
compiling redcloth_attributes.c
compiling redcloth_inline.c
compiling redcloth_scan.c
linking shared-object redcloth_scan.bundle
clang: error: unknown argument: '-multiply_definedsuppress' [-Wunused-command-line-argument-hard-error-in-future]
clang: note: this will be a hard error (cannot be downgraded to a warning) in the future
make: *** [redcloth_scan.bundle] Error 1


Gem files will remain installed in /Library/Ruby/Gems/2.0.0/gems/RedCloth-4.2.9 for inspection.
Results logged to /Library/Ruby/Gems/2.0.0/gems/RedCloth-4.2.9/ext/redcloth_scan/gem_make.out
An error occurred while installing RedCloth (4.2.9), and Bundler cannot continue.
Make sure that `gem install RedCloth -v '4.2.9'` succeeds before bundling.
</code></pre>

<p>在各种Google和StackOverflow后问题出在<code>clang: error: unknown argument: '-multiply_definedsuppress' [-Wunused-command-line-argument-hard-error-in-future]</code>这句上，原因是更新了最新的Xocde 5.1后的Apple LLVM compiler把所有无法识别的命令行选项当成了错误，下面是<a href="https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Introduction/Introduction.html">Xcode 5.1 Release Notes</a>中的解释：</p>

<blockquote><p>The Apple LLVM compiler in Xcode 5.1 treats unrecognized command-line options as errors. This issue has been seen when building both Python native extensions and Ruby Gems, where some invalid compiler options are currently specified.</p></blockquote>

<p>很感谢StackOverflow里这篇文章的帮助<a href="http://stackoverflow.com/questions/22352838/ruby-gem-install-json-fails-on-mavericks-and-xcode-5-1-unknown-argument-mul">http://stackoverflow.com/questions/22352838/ruby-gem-install-json-fails-on-mavericks-and-xcode-5-1-unknown-argument-mul</a>.</p>

<p>这个问题有两种解决办法：</p>

<ul>
<li>在Terminal里执行如下命令</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future bundle install 
</span><span class='line'>sudo ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future gem install Gemmodule </span></code></pre></td></tr></table></div></figure>


<p>然而这种方法是一种临时性的解决办法，想要永久性的解决这个问题就要用第二种方法。</p>

<ul>
<li>升级ruby的版本，升级到解决了这个问题的版本就行，貌似是2.0.0-p451，大于等于这个版本的都行，我下面的操作就是升级到了2.1.1版本。</li>
</ul>


<p>ruby的安装有两种方法，分别是<strong>rvm</strong>和<strong>rbenv</strong>，而在执行<code>rvm install ruby</code>命令时又出现了如下蛋疼的错误：</p>

<pre><code>Searching for binary rubies, this might take some time.
No binary rubies available for: osx/10.9/x86_64/ruby-2.1.1.
Continuing with compilation. Please read 'rvm help mount' to get more information on binary rubies.
Checking requirements for osx.
Installing macports...............................................
Error running 'requirements_osx_port_install_port',
showing last 15 lines of /Users/apple/.rvm/log/1395596183_ruby-2.1.1/port_install.log
checking for lockf... yes
checking for flock... yes
checking for setmode... yes
checking for strcasecmp... yes
checking for strncasecmp... yes
checking for strlcpy... yes
checking for copyfile... yes
checking for clearenv... no
checking for sysctlbyname... yes
checking if readlink conforms to POSIX 1003.1a... yes
checking CommonCrypto/CommonDigest.h usability... yes
checking CommonCrypto/CommonDigest.h presence... yes
checking for CommonCrypto/CommonDigest.h... yes
checking for Tcl configuration... configure: error: Can't find Tcl configuration definitions
++ return 1
Requirements installation failed with status: 1.
</code></pre>

<p>于是又用<strong>rbenv</strong>去升级<strong>ruby</strong>。</p>

<p>首先用如下命令安装<strong>Homebrew</strong>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"</span></code></pre></td></tr></table></div></figure>


<p>然后安装<strong>rbenv</strong>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew update
</span><span class='line'>brew install rbenv
</span><span class='line'>brew install ruby-build</span></code></pre></td></tr></table></div></figure>


<p>最后安装<strong>ruby</strong>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rbenv install 2.1.1
</span><span class='line'>rbenv local 2.1.1
</span><span class='line'>rbenv rehash</span></code></pre></td></tr></table></div></figure>


<p>按照第二种方法升级ruby后在Octopress目录下执行<code>bundle install</code>命令，问题解决，然后就可以用<strong>rake</strong>命令进行发布，预览等一系列操作了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Octopress Blog]]></title>
    <link href="http://jeffreylyg.github.io/blog/2014/03/12/my-first-octopress-blog/"/>
    <updated>2014-03-12T14:37:20+08:00</updated>
    <id>http://jeffreylyg.github.io/blog/2014/03/12/my-first-octopress-blog</id>
    <content type="html"><![CDATA[<p>很久之前就想搭一个个人<strong>Blog</strong>了，但一直苦于找不到一个合适的<strong>Blog</strong>平台。之前搞ACM的时候在CSDN上写过一些题解，主要做模板和记录的作用，写过几篇后就不了了之了。然后体验过国外很火的轻博客<a href="https://www.tumblr.com/"><strong>Tumblr</strong></a>以及国内的<a href="http://www.diandian.com/"><strong>点点</strong></a>等，这些平台都不能完全的私人定制，感觉甚是不爽。说到这儿可能会有人问为什么不去用<a href="http://wordpress.com/"><strong>WordPress</strong></a>，其实之前是有试着用<a href="http://wordpress.com/"><strong>WordPress</strong></a>去搭的，但感觉很是麻烦，先不说部署时的学习曲线，还要自己去找服务器，国内的免费服务器支持的不是很好，<strong>新浪云</strong>有支持，但免费的还是不能完全的私人定制，花钱租服务器觉得不划算，觉得还没有到花钱的地步，不是自己舍不得这笔钱，主要是认为自己才刚开始，博客一时半会儿不会到拥有大量读者的地步而且主要是自娱自乐。还有一个原因当时真得没有时间去折腾这个。所以这件事也就搁置了好久，一直到现在。</p>

<!--more-->


<p>最近偶然在Google问题浏览他人Blog的时候发现了<a href="http://octopress.org/"><strong>Octopress</strong></a>的存在，于是马上去它的官网查了查，瞬间被它的一句话所吸引：</p>

<blockquote><p>A blogging framework for hackers.</p></blockquote>

<p>于是大概看了一下它是如何部署的，原来是用<code>ruby</code>脚本帮你封装了生成静态页面以及git的一系列操作，虽然从来没用过<code>ruby</code>，但对git还是蛮熟悉的，而且它可以部署在<a href="http://pages.github.com/"><strong>Github Page</strong></a>上，所以服务器这一项完全免费还支持custom domain，于是立马开始了对<code>Octopress</code>的部署（网上有大量的Octopress的部署教程，这里不赘述了，请大家自行Google）。博文支持当下很流行的<code>Markdown</code>语法，<code>Markdown</code>确实强大而且<code>Markdown</code>还是蛮容易上手的，这里推荐一个Mac OS上很不错的Markdown编辑器<a href="http://mouapp.com/"><strong>Mou</strong></a>:</p>

<p><img src="http://mouapp.com/images/Mou_Screenshot_1.png" alt="Mou preview" /></p>

<p>随后发现了一款Octopress上非常不错的主题，第一眼看到它就喜欢上它的高大上了，这款主题叫<a href="http://shashankmehta.in/archive/2012/greyshade.html"><strong>Greyshade</strong></a>, 也就是本人现在正在用的这款主题。引入这款主题的时候会出现一个问题，那就是如果你引入了第三方评论系统<a href="http://disqus.com/"><strong>Disqus</strong></a>，那么引入这款主题后<a href="http://disqus.com/"><strong>Disqus</strong></a>后就看不见了，在网上Google了好久终于在这篇文章<a href="http://bryanone.com/blog/2014/03/01/problem-with-greyshade/">http://bryanone.com/blog/2014/03/01/problem-with-greyshade/</a>里找到了原因并有解决方案，很感谢这位博主。</p>

<p>最后，还是好基友说的那句话，搭一个Blog平台容易，但坚持写Blog不是一件容易的事。所以，总之，加油吧，在这里记录点什么。</p>
]]></content>
  </entry>
  
</feed>
